{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"chopin","text":"<p>Welcome to chopin, the Spotify playlist manager.</p>"},{"location":"#what-is-chopin","title":"What is Chopin ?","text":"<p>chopin is a user-friendly CLI to compose Spotify playlists from various sources.</p> <p>It also comes with commands to manage your playlists.</p> <p> Get started  Follow the guide  Dive in the reference</p> <p>On November 2024, Spotify removed - without notice, seven API routes. </p> <p>Unfortunately, most of chopin's features have since been downsized to the minimum feature set allowed by Spotify. </p>"},{"location":"#available-features","title":"Available features","text":"<p>Several entrypoints come with the chopin repository: </p> Commands Description compose \ud83e\udd16 Create a playlist from sources queue \ud83d\udd2e Turn your Spotify queue into a playlist shuffle \ud83d\udd00 Shuffle tracks in an existing playlist backup \ud83d\udcbe Save a summary of a playlist restore \ud83c\udd99 Restore a previously saved playlist"},{"location":"getting_started/","title":"Getting started","text":""},{"location":"getting_started/#installation","title":"Installation","text":"<p>Clone the repository and setup.</p> <p>It is advised to create a virtual environment dedicated to Chopin.</p> <pre><code>git clone git@github.com:pstfni/chopin.git\ncd chopin/\nmake setup\n</code></pre>"},{"location":"getting_started/#spotify-developer-credentials","title":"Spotify developer credentials","text":"<p>Create a Spotify Developer account and an app. The dummy application will let you use the service. Here is an example of a configuration for your application: <pre><code>Application Name: \"app\"\nWebsite: _Not needed_\nRedirect URIs: `http://localhost:8888/callback`\nBundle IDs: _Not needed_\nAndroid Packages: _Not needed_\n</code></pre></p> <p>Once your application is setup in the Spotify Web interface, you can add your credentials in the <code>.env</code> file:</p> <pre><code>client_id=\"\"\nclient_secret=\"\"\nscope=\"user-top-read,user-library-modify,playlist-modify-public,user-library-read,user-read-playback-state\"\n</code></pre> <p>More infos about the scopes and what they do is available on the Spotify Developer documentation</p>"},{"location":"getting_started/#check-everything-works","title":"Check everything works","text":"<p>Once you have:</p> <ul> <li>installed the chopin project</li> <li>created your spotify developer account and added your credentials in the <code>.env</code> file</li> </ul> <p>You can make sure everything is installed properly by running:</p> <p><code>make check</code></p> <p>It should display your user names and your recent listening habits \ud83c\udfa7</p>"},{"location":"guide/backup_and_restore/","title":"\ud83d\udd03 Save and restore playlists","text":""},{"location":"guide/backup_and_restore/#backup-save-a-playlist","title":"\ud83d\udcbe Backup (save) a playlist","text":"<p>Store and get basic statistics of an existing playlist with the <code>backup</code> command.</p> <pre><code>$ chopin backup --name \"rock\" --output data/\n\n\ud83d\udcdd Describing . . .\nWrote playlist rock in data/rock.json\n</code></pre> <p>If you don't specify a name, all your playlists will be saved</p> <p>If you specify an output directory, the entrypoint will dump all the tracks data in a readable JSON. </p> <pre><code>$ chopin backup --output data/ \n\n\ud83d\udcdd Describing . . .\nWrote playlist pop in data/pop.json\nWrote playlist rock in data/rock.json\nWrote playlist electro in data/electro.json\n</code></pre>"},{"location":"guide/backup_and_restore/#restore-playlist","title":"\ud83c\udd99 Restore playlist","text":"<p>Use a playlist backup created with the backup entrypoint to restore a playlist, and upload it back to Spotify.</p> <pre><code>$ chopin restore playlists/my_playlist.json \n</code></pre> <p>You can give a new name to your playlist:</p> <pre><code>$ chopin restore playlists/my_playlist.json --name new_name\n</code></pre>"},{"location":"guide/compose/","title":"Compose","text":"<p>Compose playlists from scratch in a few seconds with the <code>compose</code> command.</p>"},{"location":"guide/compose/#how-to-compose-your-playlist","title":"How to compose your playlist","text":"<p>You can configure your own playlist with a YAML file. First, you can give your playlist a <code>name</code>, a <code>description</code>, and a number of songs (<code>nb_songs</code>). Several subsections are available to use different sources to customize a playlist. Take the following example:</p> A composition configuration example<pre><code>name: \"Energy\"\ndescription: \"Playlist for working out\"\nnb_songs: 16\nplaylists:\n  - name: rock\n  - name: electro\n</code></pre> <p>Give your YAML configuration to the entrypoint:</p> <pre><code>$ compose --configuration playlist_composition.yaml\n</code></pre> <p>A playlist titled \"Energy\" will be added to your Spotify library. It will have 16 songs:</p> <ul> <li>8 from one of your playlist named 'rock'</li> <li>8 from another one of your playlist, 'electro'</li> </ul> <p>See the sources for all the available sources and their options.</p>"},{"location":"guide/compose/#use-weights-to-balance-your-playlist","title":"Use weights to balance your playlist","text":"<p>All sources of your playlists have a <code>weight</code> attribute. For your running playlist, you may want more \"rock\" songs than \"electro\" ones.</p> <p>The <code>weight</code> attribute can be used to ponder items. All weights will be normalized, and used to compute the number of songs per item in your final playlist.</p> A composition configuration, with weights<pre><code>name: \"Running\"\ndescription: \"Playlist for working  out\"\nnb_songs: 100\nplaylists:\n  - name: rock\n    weight: 1\n  - name: electro\n    weight: 0.5\n</code></pre> <p>Your new \"Running\" playlist will have 200 songs:</p> <ul> <li>66 from your 'rock' playlist</li> <li>34 from 'electro'</li> </ul>"},{"location":"guide/compose/#choose-how-tracks-are-selected-for-your-playlists","title":"Choose how tracks are selected for your playlists","text":"<p>By default, chopin will pick a random subset of tracks from your sources. It is possible to change this behaviour with the <code>selection_method</code> attribute. </p> <p>Selection rules for chopin sources.</p> Available rules <ul> <li><code>random</code>: The default rule, songs are picked randomly from the source.</li> <li><code>popularity</code>: songs are picked based on their         popularity score.</li> <li><code>latest</code>: the most recently released songs will be picked first.</li> <li><code>original</code>: no rule is applied, and the tracks are picked in the order they appear in the source.</li> </ul> <p>If we illustrate with the example above:</p> A composition configuration, with weights and selection methods.<pre><code>name: \"Running\"\ndescription: \"Playlist for jogging\"\nnb_songs: 100\nplaylists:\n  - name: rock\n    weight: 1\n  - name: electro\n    weight: 0.5\n    selection_method: latest\nuris:\n  - name: 4nutUe1JAzhJSna4mwSIw1  # FIP, best-of du mois\n    selection_method: popularity\n</code></pre> <p>Your new \"Running\" playlist will have 200 songs:</p> <ul> <li>40 from your 'rock' playlist</li> <li>The 20 most recently released songs from your 'electro' playlist</li> <li>40 songs from the \"FIP, Best of du mois\" playlist. These songs will be the most popular (on Spotify) songs from said playlist.</li> </ul>"},{"location":"guide/compose/#use-release_range-to-filter-tracks-by-their-release-date","title":"Use <code>release_range</code> to filter tracks by their release date","text":"<p>The <code>release_range</code> option let you configure a date range for the tracks you want in your playlist.</p> A playlist for this year releases<pre><code>name: \"Releases of the year\"\nnb_songs: 100\nplaylists:\n  - name: pop\n  - name: rock\nrelease_range: [\"01/01/2023\", ]\n</code></pre>"},{"location":"guide/compose/#available-sources","title":"Available sources","text":"<p>There are many ways to compose your playlist, not just artists and your own playlists. sources  present the options available.</p>"},{"location":"guide/queue/","title":"\ud83d\udd2e Queue","text":"<p>You cannot shuffle songs in your queue, so let's create a playlist to do so !</p> <p>The <code>from-queue</code> command create a playlist from the songs in your queue.</p> <pre><code>$ chopin from-queue \n\n\ud83d\udd2e Queuing . . .\nPlaylist '\ud83d\udd2e Queued Mix' successfully created.\n</code></pre> <p>Spotify API limitation</p> <p>Queues are hard to retrieve from the Spotify API. For this reason, be aware that :     - You must be playing from a device for this entrypoint to work.     - The entrypoint will retrieve up to 20 songs from your queue, but not more.</p>"},{"location":"guide/shuffle/","title":"\ud83d\udd00 Shuffle","text":"<p>Sometimes you want to create a random order for your songs, but play them in sequential order.</p> <p>The <code>shuffle</code> command is a fast utility to shuffle playlist tracks in your playlist</p> <pre><code>$ chopin shuffle {name} \n\ud83d\udd00 Shuffling . . .\nPlaylist {name} succesfully shuffled.\n</code></pre>"},{"location":"guide/sources/","title":"Available sources for playlist composition","text":""},{"location":"guide/sources/#playlists","title":"Playlists","text":"<p>A list of one or more of the current user playlists. </p> Add songs from playlists<pre><code>name: \"New playlist\"\nnb_songs: 100\nplaylists:\n  - name: rock\n  - name: chill\n  - name: pop\n    weight: 0.25\n</code></pre> About playlist names <p>Playlists are given with their simplified name, stripped of emojis and spaces. For example, <code>rock 70s \u270c</code> should be written as <code>rock70s</code> in the configuration.</p> <p>You can run the following code snippet to figure out the correct name you should give: <pre><code>playlist_name = \"rock 70s \u270c\"\npython -c \"from utils import simplify_string; print(simplify_string($playlist_name))\"\n</code></pre></p>"},{"location":"guide/sources/#history","title":"History","text":"<p><code>history</code> lets you add your favourite songs from the past! Three time ranges are available:</p> <ul> <li><code>short_term</code> for the last 4 weeks</li> <li><code>medium_term</code> for the last 6 months</li> <li><code>long_term</code> for your all-time best.</li> </ul> Add songs from your most-listened titles<pre><code>history:\n  - time_range: \"short_term\"\n  - time_range: \"long_term\"\n    weight: 0.25\n</code></pre>"},{"location":"guide/sources/#uris","title":"Uris","text":"<p>With uris, you can use any kind of playlist in your composition. Simply add the Spotify playlist uri or url in your YAML.</p> <p>Warning</p> <p>Spotify-owned playlists are not supported, their content is not accessible through the API. </p> Add songs from any Spotify public playlist<pre><code>uris:\n  - name: 50FTlBiOVTyPgVtPYVUzdn\n  - name: 7oK3UXsHYmC3PYGQFY5IOb\n    weight: 0.5\n  - name: https://open.spotify.com/playlist/7oK3UXsHYmC3PYGQFY5IOb?si=eae4b209bee740f8\n    weight: 0.25\n</code></pre> <p>Playlist URI or playlist URL ?</p> <p>Both are supported. The URL link to share a playlist features its URI. For example: https://open.spotify.com/playlist/7oK3UXsHYmC3PYGQFY5IOb?si=eae4b209bee740f8 is a link for the  playlist URI <code>7oK3UXsHYmC3PYGQFY5IOb</code>.</p> Some playlist URIs to cover your needs <ul> <li><code>7oK3UXsHYmC3PYGQFY5IOb</code> : Bob Dylan, the philosophy of modern song</li> <li><code>50FTlBiOVTyPgVtPYVUzdn</code> : Les Inrockuptibles, Tr\u00e9sors Cach\u00e9s</li> <li>...</li> </ul>"},{"location":"guide/sources/#putting-all-this-together","title":"Putting all this together","text":"<p>You can add as many items from as many sections as you'd like ! And create all kinds of playlists</p> A playlist for your monthly best-of <pre><code>name: \"\ud83c\udf54 Monthly Best Of\"\nnb_songs: 50\nhistory:\n    - time_range: short_term\n</code></pre> A playlist for a chill evening <pre><code>name: \"\ud83c\udf06 Calm Tunes\"\nnb_songs: 100\nplaylists:\n    - name: chill\n      selection_method: latest\nuris:\n    - name: https://open.spotify.com/playlist/6LSRWYpEoo8KiXenl2xHOP?si=e83a89df1dca4728  # Les inrocks, tr\u00e9sors cach\u00e9s\n    - name: https://open.spotify.com/playlist/4nutUe1JAzhJSna4mwSIw1?si=71f802c91a04416e  # FIP, best-of du mois\n</code></pre>"},{"location":"guide/sources/#deprecated-sources","title":"Deprecated sources","text":"<p>In November 2024 and without warning, Spotify deprecated several entrypoints from their public API, removed features and access on others. Some Chopin features are no longer available, but might come back one day.</p>"},{"location":"guide/sources/#features","title":"Features","text":"<p>Unavailable since Spotify removed access to the <code>audio_features</code> API routes.</p> <p>With features, you can add recommendations to your playlist. Based on the current playlist composition, and  the feature <code>value</code>, recommended songs will be added. Available features are described in the API reference</p> <p>Features come from Spotify audio features analysis</p> Recommend songs based on track features<pre><code>artists:\n  - name: David Bowie\n  - name: The Beatles\nfeatures:\n  - name: acousticness\n    value: 0.6\n  - name: popularity\n    value: 80\n</code></pre> <p>The above composition configuration will:</p> <ol> <li>Add Bowie and Beatles songs to your playlists. </li> <li>Based on these songs, it will recommend relatively acoustic new ones.</li> <li>Finally, it will recommend popular songs.</li> </ol>"},{"location":"guide/sources/#artists","title":"Artists","text":"<p>A list of artists to pick songs from. The <code>name</code> is used to query the Spotify API and retrieve songs from Spotify's This is ... playlists.</p> Add songs from artists<pre><code>name: \"New playlist\"\nnb_songs: 20\nartists:\n  - name: David Bowie\n  - name: The Beatles\n  - name: Johnny Cash\n    weight: 0.25\n</code></pre>"},{"location":"guide/sources/#radios","title":"Radios","text":"<p>A list of artist's radios to pick songs from. The term \"radio\" refers here to the  Spotify's Artist Name Radio playlists. </p> <p>Songs from radios will include a few songs from the artist, and tracks from related artists.</p> Add songs from radios of artists<pre><code>name: \"New playlist\"\nnb_songs: 50\nradios:\n  - name: Pulp\n  - name: Elvis Costello\n  - name: Elliott Smith\n    weight: 0.25\n</code></pre>"},{"location":"guide/sources/#mixes","title":"Mixes","text":"<p>With mixes, you can search for genre-specific playlists curated by Spotify, such as \"Bossa Nova Mix\", \"New Wave Mix\",  or \"Singer Songwriter Mix\" for example.</p> Add songs from genre playlists<pre><code>mixes:\n  - name: \"Bossa Nova\"\n  - name: \"80s\"\n  - name: \"Covers\"\n</code></pre>"},{"location":"reference/","title":"Index","text":""},{"location":"reference/#reference","title":"Reference","text":"<p>chopin comes with dedicated schemas to read and store Spotify APIs information. Those schemas, along  with managers responsible for interacting with them, makes it easy to create and add commands to play with the  Spotify API.</p>"},{"location":"reference/client/","title":"Spotify API related operations","text":"<p>Spotipy client endpoints.</p>"},{"location":"reference/client/#chopin.client.endpoints.add_to_queue","title":"<code>add_to_queue(track)</code>","text":"<p>Add a track to the user's queue.</p> <p>Parameters:</p> Name Type Description Default <code>track</code> <code>TrackData</code> <p>Track to add</p> required Source code in <code>chopin/client/endpoints.py</code> <pre><code>def add_to_queue(track: TrackData) -&gt; None:\n    \"\"\"Add a track to the user's queue.\n\n    Args:\n        track: Track to add\n    \"\"\"\n    _client.add_to_queue(track.uri)\n</code></pre>"},{"location":"reference/client/#chopin.client.endpoints.add_tracks_to_playlist","title":"<code>add_tracks_to_playlist(playlist_id, track_ids)</code>","text":"<p>Add tracks to a user playlist.</p> <p>Parameters:</p> Name Type Description Default <code>playlist_id</code> <code>str</code> <p>URI of the target playlist</p> required <code>track_ids</code> <code>list[str]</code> <p>IDs for the tracks.</p> required Source code in <code>chopin/client/endpoints.py</code> <pre><code>def add_tracks_to_playlist(playlist_id: str, track_ids: list[str]) -&gt; None:\n    \"\"\"Add tracks to a user playlist.\n\n    Args:\n        playlist_id: URI of the target playlist\n        track_ids: IDs for the tracks.\n    \"\"\"\n    paginated_tracks = [track_ids[i : i + 99] for i in range(0, len(track_ids), 99)]\n    for page_tracks in paginated_tracks:\n        _client.playlist_add_items(playlist_id, page_tracks)\n</code></pre>"},{"location":"reference/client/#chopin.client.endpoints.create_user_playlist","title":"<code>create_user_playlist(user_id, name, description='Playlist created with Chopin')</code>","text":"<p>Create a playlist in the user library.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>ID of the user for which to add a playlist</p> required <code>name</code> <code>str</code> <p>Name for the playlist</p> required <code>description</code> <code>str</code> <p>Optional description for the playlist</p> <code>'Playlist created with Chopin'</code> <p>Returns:</p> Type Description <code>PlaylistData</code> <p>Created playlist data.</p> Source code in <code>chopin/client/endpoints.py</code> <pre><code>def create_user_playlist(user_id: str, name: str, description: str = \"Playlist created with Chopin\") -&gt; PlaylistData:\n    \"\"\"Create a playlist in the user library.\n\n    Args:\n        user_id: ID of the user for which to add a playlist\n        name: Name for the playlist\n        description: Optional description for the playlist\n\n    Returns:\n        Created playlist data.\n    \"\"\"\n    playlist = _client.user_playlist_create(user=user_id, name=name, description=description)\n    return PlaylistData(name=playlist[\"name\"], uri=playlist[\"uri\"], id=playlist[\"id\"])\n</code></pre>"},{"location":"reference/client/#chopin.client.endpoints.get_album_tracks","title":"<code>get_album_tracks(album_id)</code>","text":"<p>Get album tracks for the given album.</p> <p>Parameters:</p> Name Type Description Default <code>album_id</code> <code>str</code> <p>The id of the album.</p> required <p>Returns:</p> Type Description <code>list[TrackData]</code> <p>A list of tracks from said album.</p> Source code in <code>chopin/client/endpoints.py</code> <pre><code>def get_album_tracks(album_id: str) -&gt; list[TrackData]:\n    \"\"\"Get album tracks for the given album.\n\n    Args:\n        album_id: The id of the album.\n\n    Returns:\n        A list of tracks from said album.\n    \"\"\"\n    response = _client.album_tracks(album_id=album_id)[\"items\"]\n    return [TrackData(**track) for track in response]\n</code></pre>"},{"location":"reference/client/#chopin.client.endpoints.get_artist_top_tracks","title":"<code>get_artist_top_tracks(artist, max_tracks=20)</code>","text":"<p>Get an artist top tracks.</p> <p>Parameters:</p> Name Type Description Default <code>artist</code> <code>ArtistData</code> <p>current artist.</p> required <code>max_tracks</code> <code>int</code> <p>maximum number of tracks to find.</p> <code>20</code> <p>Returns:</p> Type Description <code>list[TrackData]</code> <p>A list of track data.</p> Source code in <code>chopin/client/endpoints.py</code> <pre><code>def get_artist_top_tracks(artist: ArtistData, max_tracks: int = 20) -&gt; list[TrackData]:\n    \"\"\"Get an artist top tracks.\n\n    Args:\n        artist: current artist.\n        max_tracks: maximum number of tracks to find.\n\n    Returns:\n        A list of track data.\n    \"\"\"\n    response = _client.artist_top_tracks(artist_id=artist.id)\n    tracks = response[\"tracks\"]\n    return [TrackData(**track) for track in random.sample(tracks, min(len(tracks), max_tracks))]\n</code></pre>"},{"location":"reference/client/#chopin.client.endpoints.get_current_user","title":"<code>get_current_user()</code>  <code>cached</code>","text":"<p>Retrieve the current user.</p> <p>Returns:</p> Type Description <code>UserData</code> <p>User data.</p> Source code in <code>chopin/client/endpoints.py</code> <pre><code>@lru_cache\ndef get_current_user() -&gt; UserData:\n    \"\"\"Retrieve the current user.\n\n    Returns:\n        User data.\n    \"\"\"\n    user = _client.current_user()\n    return UserData(name=user[\"display_name\"], id=user[\"id\"], uri=user[\"uri\"])\n</code></pre>"},{"location":"reference/client/#chopin.client.endpoints.get_currently_playing","title":"<code>get_currently_playing()</code>","text":"<p>Get the track being played.</p> <p>Returns:</p> Type Description <code>TrackData | None</code> <p>The track data of the track; or nothing if the user doesn't have an active listening session.</p> Source code in <code>chopin/client/endpoints.py</code> <pre><code>def get_currently_playing() -&gt; TrackData | None:\n    \"\"\"Get the track being played.\n\n    Returns:\n        The track data of the track; or nothing if the user doesn't have an active listening session.\n    \"\"\"\n    response = _client.current_playback()\n    if not response or response[\"currently_playing_type\"] != \"track\":\n        return None\n    return TrackData.model_validate(response[\"item\"])\n</code></pre>"},{"location":"reference/client/#chopin.client.endpoints.get_likes","title":"<code>get_likes()</code>","text":"<p>Get user liked tracks.</p> <p>Returns:</p> Type Description <code>list[TrackData]</code> <p>The liked tracks.</p> Source code in <code>chopin/client/endpoints.py</code> <pre><code>def get_likes() -&gt; list[TrackData]:\n    \"\"\"Get user liked tracks.\n\n    Returns:\n        The liked tracks.\n    \"\"\"\n    offset = 0\n    tracks = []\n    while True:\n        response = _client.current_user_saved_tracks(limit=20, offset=offset)\n        tracks.extend(response.get(\"items\"))\n        offset += 20\n        if not response.get(\"next\"):\n            break\n    return [TrackData(**track[\"track\"]) for track in tracks]\n</code></pre>"},{"location":"reference/client/#chopin.client.endpoints.get_named_playlist","title":"<code>get_named_playlist(name)</code>","text":"<p>Find a user playlist based on its name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>A string identifying the playlist name</p> required <p>Returns:</p> Type Description <code>PlaylistData</code> <p>The playlist data</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>the playlist <code>name</code> was not found.</p> Source code in <code>chopin/client/endpoints.py</code> <pre><code>def get_named_playlist(name: str) -&gt; PlaylistData:\n    \"\"\"Find a user playlist based on its name.\n\n    Args:\n        name: A string identifying the playlist name\n\n    Returns:\n        The playlist data\n\n    Raises:\n        ValueError: the playlist `name` was not found.\n    \"\"\"\n    playlists = get_user_playlists()\n    names = [simplify_string(p.name) for p in playlists]\n    try:\n        index_ = names.index(simplify_string(name))\n    except ValueError as exc:\n        raise ValueError(f\"Couldn't find playlist {name} in user playlists\") from exc\n    return playlists[index_]\n</code></pre>"},{"location":"reference/client/#chopin.client.endpoints.get_playlist_tracks","title":"<code>get_playlist_tracks(playlist_id, release_date_range=None)</code>","text":"<p>Get tracks of a given playlist.</p> <p>Parameters:</p> Name Type Description Default <code>playlist_id</code> <code>str</code> <p>The uri of the playlist.</p> required <code>release_date_range</code> <code>tuple[date, date] | None</code> <p>A date range; tracks to retrieve must have been released in this range.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[TrackData]</code> <p>A list of track uuids.</p> Source code in <code>chopin/client/endpoints.py</code> <pre><code>def get_playlist_tracks(\n    playlist_id: str, release_date_range: tuple[datetime.date, datetime.date] | None = None\n) -&gt; list[TrackData]:\n    \"\"\"Get tracks of a given playlist.\n\n    Args:\n        playlist_id: The uri of the playlist.\n        release_date_range: A date range; tracks to retrieve must have been released in this range.\n\n\n    Returns:\n        A list of track uuids.\n    \"\"\"\n    offset: int = 0\n    tracks: list[TrackData] = []\n    response: dict[str, Any] = {\"response\": []}\n\n    while response:\n        response = _client.playlist_items(\n            playlist_id,\n            offset=offset,\n            fields=constants.TRACK_FIELDS,\n            additional_types=[\"track\"],\n        )\n        offset += len(response[\"items\"])\n\n        response_tracks = _validate_tracks(response[\"items\"])\n        if release_date_range:\n            response_tracks = [\n                track\n                for track in response_tracks\n                if release_date_range[0].date() &lt;= track.album.release_date &lt;= release_date_range[1].date()\n            ]\n        tracks.extend(response_tracks)\n\n        if len(response[\"items\"]) == 0:\n            break\n    return tracks\n</code></pre>"},{"location":"reference/client/#chopin.client.endpoints.get_queue","title":"<code>get_queue()</code>","text":"<p>Get the current user's listening queue.</p> <p>Returns:</p> Type Description <code>list[TrackData]</code> <p>The list of track data in the user's queue.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>if the user doesn't have an active (ie: doesn't have a track playing)</p> Note <p>API Call has to be custom made, waiting for its implementation in Spotipy.</p> Source code in <code>chopin/client/endpoints.py</code> <pre><code>def get_queue() -&gt; list[TrackData]:\n    \"\"\"Get the current user's listening queue.\n\n    Returns:\n        The list of track data in the user's queue.\n\n    Raises:\n        ValueError: if the user doesn't have an active (ie: doesn't have a track playing)\n\n    Note:\n        API Call has to be custom made, waiting for its implementation in Spotipy.\n    \"\"\"\n    current_playback = _client.current_playback()\n    if not current_playback or not current_playback.get(\"is_playing\"):\n        raise ValueError(\n            \"Spotify should be active on a device and the playback should be on for the get_queue endpoint to work.\"\n        )\n\n    response = _client.queue()\n    return [TrackData(**track) for track in response.get(\"queue\")]\n</code></pre>"},{"location":"reference/client/#chopin.client.endpoints.get_top_artists","title":"<code>get_top_artists(time_range, limit)</code>","text":"<p>Get top artists for the current user.</p> <p>Parameters:</p> Name Type Description Default <code>time_range</code> <code>Literal['short_term', 'medium_term', 'long_term']</code> <p>The time scope of top artists</p> required <code>limit</code> <code>int</code> <p>A maximum number of artists to fetch</p> required <p>Returns:</p> Type Description <code>list[ArtistData]</code> <p>The user top artists for the given scope.</p> Source code in <code>chopin/client/endpoints.py</code> <pre><code>def get_top_artists(time_range: Literal[\"short_term\", \"medium_term\", \"long_term\"], limit: int) -&gt; list[ArtistData]:\n    \"\"\"Get top artists for the current user.\n\n    Args:\n        time_range: The time scope of top artists\n        limit: A maximum number of artists to fetch\n\n    Returns:\n        The user top artists for the given scope.\n    \"\"\"\n    response = _client.current_user_top_artists(limit=limit, time_range=time_range)[\"items\"]\n    return [ArtistData(**artist) for artist in response]\n</code></pre>"},{"location":"reference/client/#chopin.client.endpoints.get_top_tracks","title":"<code>get_top_tracks(time_range, limit)</code>","text":"<p>Get top tracks for the current user.</p> <p>Parameters:</p> Name Type Description Default <code>time_range</code> <code>Literal['short_term', 'medium_term', 'long_term']</code> <p>The scope of the 'top' tracks.</p> required <code>limit</code> <code>int</code> <p>A maximum number of tracks to fetch</p> required <p>!!! note     Time range is as follow:     - short_term: last month     - medium_term: last 6 months     - long_term: all time</p> <p>Note</p> <p>There is a Spotify limit for a user's top tracks. If <code>limit</code> is above, it will be reduced to the accepted number.</p> <p>Returns:</p> Type Description <code>list[TrackData]</code> <p>The user top tracks for the given time scope.</p> Source code in <code>chopin/client/endpoints.py</code> <pre><code>def get_top_tracks(time_range: Literal[\"short_term\", \"medium_term\", \"long_term\"], limit: int) -&gt; list[TrackData]:\n    \"\"\"Get top tracks for the current user.\n\n    Args:\n        time_range: The scope of the 'top' tracks.\n        limit: A maximum number of tracks to fetch\n\n     !!! note\n        Time range is as follow:\n        - short_term: last month\n        - medium_term: last 6 months\n        - long_term: all time\n\n    !!! note\n        There is a Spotify limit for a user's top tracks.\n        If `limit` is above, it will be reduced to the accepted number.\n\n    Returns:\n        The user top tracks for the given time scope.\n    \"\"\"\n    if limit &gt; constants.SPOTIFY_API_HISTORY_LIMIT:\n        logger.warning(\n            f\"Asked for {limit} tracks for {time_range} best songs, \"\n            f\"but Spotify API limits to {constants.SPOTIFY_API_HISTORY_LIMIT}\"\n        )\n        limit = constants.SPOTIFY_API_HISTORY_LIMIT\n    response = _client.current_user_top_tracks(limit=limit, time_range=time_range)[\"items\"]\n    return [TrackData(**track) for track in response]\n</code></pre>"},{"location":"reference/client/#chopin.client.endpoints.get_user_playlists","title":"<code>get_user_playlists()</code>  <code>cached</code>","text":"<p>Retrieve the playlists of the current user.</p> <p>Returns:</p> Type Description <code>list[PlaylistData]</code> <p>A list of playlist data.</p> Source code in <code>chopin/client/endpoints.py</code> <pre><code>@lru_cache\ndef get_user_playlists() -&gt; list[PlaylistData]:\n    \"\"\"Retrieve the playlists of the current user.\n\n    Returns:\n        A list of playlist data.\n    \"\"\"\n    playlists = _client.current_user_playlists().get(\"items\", [])\n    return [PlaylistData(name=simplify_string(p[\"name\"]), uri=p[\"uri\"], id=p[\"id\"]) for p in playlists]\n</code></pre>"},{"location":"reference/client/#chopin.client.endpoints.like_tracks","title":"<code>like_tracks(track_uris)</code>","text":"<p>Add tracks to the user' library.</p> <p>Parameters:</p> Name Type Description Default <code>track_uris</code> <code>list[str]</code> <p>Tracks to save.</p> required Source code in <code>chopin/client/endpoints.py</code> <pre><code>def like_tracks(track_uris: list[str]) -&gt; None:\n    \"\"\"Add tracks to the user' library.\n\n    Args:\n        track_uris: Tracks to save.\n    \"\"\"\n    _client.current_user_saved_tracks_add(track_uris)\n</code></pre>"},{"location":"reference/client/#chopin.client.endpoints.replace_tracks_in_playlist","title":"<code>replace_tracks_in_playlist(playlist_id, track_ids)</code>","text":"<p>Replace tracks in a given playlist.</p> <p>Parameters:</p> Name Type Description Default <code>playlist_id</code> <code>str</code> <p>URI of the target playlist. All of its tracks will be removed!</p> required <code>track_ids</code> <code>list[str]</code> <p>New tracks to add in the playlist.</p> required Source code in <code>chopin/client/endpoints.py</code> <pre><code>def replace_tracks_in_playlist(playlist_id: str, track_ids: list[str]) -&gt; None:\n    \"\"\"Replace tracks in a given playlist.\n\n    Args:\n        playlist_id: URI of the target playlist. All of its tracks will be removed!\n        track_ids: New tracks to add in the playlist.\n    \"\"\"\n    tracks_to_remove = get_playlist_tracks(playlist_id)\n    tracks_to_remove_ids = [track.id for track in tracks_to_remove]\n    paginated_tracks = [tracks_to_remove_ids[i : i + 99] for i in range(0, len(tracks_to_remove_ids), 99)]\n    for page_tracks in paginated_tracks:\n        _client.playlist_remove_all_occurrences_of_items(playlist_id, page_tracks)\n    add_tracks_to_playlist(playlist_id, track_ids)\n</code></pre>"},{"location":"reference/client/#chopin.client.endpoints.search_artist","title":"<code>search_artist(artist_name)</code>","text":"<p>Search an artist.</p> <p>Parameters:</p> Name Type Description Default <code>artist_name</code> <code>str</code> <p>Name of the artist</p> required <p>Returns:</p> Type Description <code>ArtistData | None</code> <p>Artist data, if found.</p> Source code in <code>chopin/client/endpoints.py</code> <pre><code>def search_artist(artist_name: str) -&gt; ArtistData | None:\n    \"\"\"Search an artist.\n\n    Args:\n        artist_name: Name of the artist\n\n    Returns:\n        Artist data, if found.\n    \"\"\"\n    response = _client.search(q=artist_name, limit=10, type=\"artist\", market=\"fr\")[\"artists\"]\n    items = response.get(\"items\")\n    matched_artists = [artist for artist in items if match_strings([artist[\"name\"], artist_name])]\n    if matched_artists:\n        return ArtistData(**matched_artists[0])\n</code></pre>"},{"location":"reference/entrypoints/","title":"Commands","text":"<p>Compose a playlist entrypoint.</p> <p>Create a playlist from the queue entrypoint.</p> <p>Entrypoint to shuffle_playlist a playlist.</p>"},{"location":"reference/entrypoints/#chopin.cli.compose.compose","title":"<code>compose</code>","text":"<p>Compose a playlist from a composition configuration.</p> <p>You can use a YAML file to specify playlists and artists should be used, and weigh them.</p> Source code in <code>chopin/cli/compose.py</code> <pre><code>@click.command()\n@click.argument(\"configuration\", type=click.Path(exists=True, path_type=Path))\ndef compose(\n    configuration: Path,\n):\n    \"\"\"Compose a playlist from a composition configuration.\n\n    You can use a YAML file to specify playlists and artists should be\n    used, and weigh them.\n    \"\"\"\n    click.echo(\"\ud83e\udd16 Composing . . .\")\n\n    yaml = YAML(typ=\"safe\", pure=True)\n    config = ComposerConfig.model_validate(yaml.load(open(configuration)))\n\n    tracks = compose_playlist(composition_config=config)\n\n    playlist = create(name=config.name, description=config.description, overwrite=True)\n    fill(uri=playlist.uri, tracks=tracks)\n    click.echo(f\"Playlist '{playlist.name}' successfully created.\")\n</code></pre>"},{"location":"reference/entrypoints/#chopin.cli.compose.compose_from_new_releases","title":"<code>compose_from_new_releases</code>","text":"<p>Compose a playlist based on recent releases.</p> <p>Parameters:</p> Name Type Description Default <code>configuration_path</code> <code>Path</code> <p>The composition configuration, <code>confs/recent.yaml</code> by default.</p> <code>Path('confs/recent.yaml')</code> Source code in <code>chopin/cli/compose.py</code> <pre><code>def compose_from_new_releases(\n    configuration_path: Path = Path(\"confs/recent.yaml\"),\n):\n    \"\"\"Compose a playlist based on recent releases.\n\n    Args:\n        configuration_path: The composition configuration, `confs/recent.yaml` by default.\n    \"\"\"\n    LOGGER.info(\"\ud83c\udd95 Composing with new releases\")\n    yaml = YAML(typ=\"safe\", pure=True)\n    config = ComposerConfig.model_validate(yaml.load(open(configuration_path)))\n    config.release_range = ((datetime.now() - timedelta(days=15)).date(), datetime.now().date())\n    tracks = compose_playlist(composition_config=config)\n\n    playlist = create(name=config.name, description=config.description, overwrite=True)\n    fill(uri=playlist.uri, tracks=tracks)\n    LOGGER.info(f\"Playlist '{playlist.name}' successfully created.\")\n</code></pre>"},{"location":"reference/entrypoints/#chopin.cli.from_queue.from_queue","title":"<code>from_queue</code>","text":"<p>Create a playlist and shuffle it from the user's queue.</p> <p>Warning</p> <p>Due to Spotify API limits, you must be playing a song on an</p> <p>active device for this to work.</p> <p>Warning</p> <p>Due to Spotify API limits, the maximum number of songs you can</p> <p>use is 20.</p> Source code in <code>chopin/cli/from_queue.py</code> <pre><code>@click.command()\n@click.argument(\"name\", type=str, default=constants.QUEUED_MIX.name, required=False)\ndef from_queue(name: str):\n    \"\"\"Create a playlist and shuffle it from the user's queue.\n\n    !!! warning\n\n        Due to Spotify API limits, you must be _playing_ a song on an\n    active device for this to work.\n\n    !!! warning\n\n        Due to Spotify API limits, the maximum number of songs you can\n    use is 20.\n    \"\"\"\n    click.echo(\"\ud83d\udd2e Queuing . . .\")\n    create_playlist_from_queue(name)\n    click.echo(f\"Playlist '{name}' successfully created.\")\n</code></pre>"},{"location":"reference/entrypoints/#chopin.cli.shuffle.shuffle","title":"<code>shuffle</code>","text":"<p>Shuffle an existing playlist.</p> Source code in <code>chopin/cli/shuffle.py</code> <pre><code>@click.command()\n@click.argument(\"name\", type=str)\ndef shuffle(\n    name: str,\n):\n    \"\"\"Shuffle an existing playlist.\"\"\"\n    click.echo(\"\ud83d\udd00 Shuffling ...\")\n    playlist = shuffle_playlist(name)\n    click.echo(f\"Playlist {playlist.name} successfully shuffled.\")\n</code></pre>"},{"location":"reference/managers/","title":"Managers","text":"<p>Operations on spotify playlists.</p> <p>Operations on spotify tracks.</p>"},{"location":"reference/managers/#chopin.managers.playlist.create","title":"<code>create(name, description='Randomly Generated Mix', overwrite=True)</code>","text":"<p>Create a new, empty, playlist.</p> <p>Warning</p> <p>If the <code>name</code> of the playlist is an existing playlist, and overwrite is <code>True</code>, the said playlist will be emptied.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>name of your playlist.</p> required <code>description</code> <code>str</code> <p>description of your playlist</p> <code>'Randomly Generated Mix'</code> <code>overwrite</code> <code>bool</code> <p>Overwrite the existing playlist if the <code>name</code> is already used.</p> <code>True</code> <p>Returns:</p> Type Description <code>PlaylistData</code> <p>Created playlist</p> Source code in <code>chopin/managers/playlist.py</code> <pre><code>def create(name: str, description: str = \"Randomly Generated Mix\", overwrite: bool = True) -&gt; PlaylistData:\n    \"\"\"Create a new, empty, playlist.\n\n    !!! warning\n        If the `name` of the playlist is an existing playlist, and overwrite is `True`, the said playlist will\n        be emptied.\n\n    Args:\n        name: name of your playlist.\n        description: description of your playlist\n        overwrite: Overwrite the existing playlist if the `name` is already used.\n\n    Returns:\n        Created playlist\n    \"\"\"\n    user_playlists = get_user_playlists()\n    target_playlist = [playlist for playlist in user_playlists if playlist.name == simplify_string(name)]\n    if target_playlist:\n        if overwrite:\n            replace_tracks_in_playlist(target_playlist[0].id, [])\n            return target_playlist[0]\n        else:\n            raise ValueError(\n                f\"Trying to create a playlist {name} but there is already such a playlist.\"\n                \"Use `overwrite=True` if you want to erase the playlist.\"\n            )\n    return create_playlist(name=name, description=description)\n</code></pre>"},{"location":"reference/managers/#chopin.managers.playlist.create_playlist","title":"<code>create_playlist(name, description='Playlist created with Chopin')</code>","text":"<p>Create a playlist in the user library.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name for the playlist</p> required <code>description</code> <code>str</code> <p>Optional description for the playlist</p> <code>'Playlist created with Chopin'</code> <p>Returns:</p> Type Description <code>PlaylistData</code> <p>Created playlist data.</p> Source code in <code>chopin/managers/playlist.py</code> <pre><code>def create_playlist(name: str, description: str = \"Playlist created with Chopin\") -&gt; PlaylistData:\n    \"\"\"Create a playlist in the user library.\n\n    Args:\n        name: Name for the playlist\n        description: Optional description for the playlist\n\n    Returns:\n        Created playlist data.\n    \"\"\"\n    user = get_current_user()\n    return create_user_playlist(user_id=user.id, name=name, description=description)\n</code></pre>"},{"location":"reference/managers/#chopin.managers.playlist.create_playlist_from_queue","title":"<code>create_playlist_from_queue(name, description='Mix generated from queue')</code>","text":"<p>Create a playlist from the user's queue.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the playlist</p> required <code>description</code> <code>str</code> <p>An optional description</p> <code>'Mix generated from queue'</code> <p>Returns:</p> Type Description <code>PlaylistData</code> <p>The created playlist</p> Notes <p>Due to Spotify limitations, only 20 songs from the queue can be fetched and added to the playlist.</p> Source code in <code>chopin/managers/playlist.py</code> <pre><code>def create_playlist_from_queue(name: str, description: str = \"Mix generated from queue\") -&gt; PlaylistData:\n    \"\"\"Create a playlist from the user's queue.\n\n    Args:\n        name: The name of the playlist\n        description: An optional description\n\n    Returns:\n        The created playlist\n\n    Notes:\n        Due to Spotify limitations, only 20 songs from the queue can be fetched and added to the playlist.\n    \"\"\"\n    playlist = create(name, description, overwrite=True)\n    tracks = get_queue()\n    fill(uri=playlist.uri, tracks=tracks)\n    return playlist\n</code></pre>"},{"location":"reference/managers/#chopin.managers.playlist.doppelganger_playlist","title":"<code>doppelganger_playlist(source_playlist, new_playlist)</code>","text":"<p>Create a \"doppelganger\", a similar playlist from an existing one.</p> <p>Parameters:</p> Name Type Description Default <code>source_playlist</code> <code>str</code> <p>The name of the playlist to copy.</p> required <code>new_playlist</code> <code>str</code> <p>The name of the new playlist.</p> required <p>Returns:</p> Type Description <code>PlaylistData</code> <p>The created playlist.</p> Source code in <code>chopin/managers/playlist.py</code> <pre><code>def doppelganger_playlist(source_playlist: str, new_playlist: str) -&gt; PlaylistData:\n    \"\"\"Create a \"doppelganger\", a similar playlist from an existing one.\n\n    Args:\n        source_playlist: The name of the playlist to copy.\n        new_playlist: The name of the new playlist.\n\n    Returns:\n        The created playlist.\n    \"\"\"\n    playlist = get_named_playlist(source_playlist)\n    tracks = get_playlist_tracks(playlist.id)\n\n    albums_tracks: dict[str, list[TrackData]] = {}\n    new_tracks: list[TrackData] = []\n    for track in tracks:\n        album_id = track.album.id\n        if album_id not in albums_tracks:\n            albums_tracks[album_id] = get_album_tracks(album_id)\n        new_tracks.append(random.choice(albums_tracks[album_id]))\n\n    if new_tracks:\n        doppelganger_playlist = create(new_playlist, overwrite=True)\n        fill(doppelganger_playlist.id, tracks=new_tracks)\n        return doppelganger_playlist\n    logger.info(f\"No tracks could be generated from playlist {source_playlist}. The {new_playlist} was not created.\")\n</code></pre>"},{"location":"reference/managers/#chopin.managers.playlist.dump","title":"<code>dump(playlist, filepath)</code>","text":"<p>Dump a playlist in a JSON format.</p> <p>Parameters:</p> Name Type Description Default <code>playlist</code> <code>PlaylistSummary</code> <p>The playlist to write</p> required <code>filepath</code> <code>Path</code> <p>Target file to receive the dump</p> required Source code in <code>chopin/managers/playlist.py</code> <pre><code>def dump(playlist: PlaylistSummary, filepath: Path):\n    \"\"\"Dump a playlist in a JSON format.\n\n    Args:\n        playlist: The playlist to write\n        filepath: Target file to receive the dump\n    \"\"\"\n    json_str = playlist.model_dump_json()\n    with open(filepath, \"w\") as f:\n        f.write(json_str)\n</code></pre>"},{"location":"reference/managers/#chopin.managers.playlist.fill","title":"<code>fill(uri, tracks)</code>","text":"<p>Fill a playlist with tracks.</p> <p>Note</p> <p>Duplicate tracks will be removed.</p> <p>Parameters:</p> Name Type Description Default <code>uri</code> <code>str</code> <p>uri of the playlist to fill</p> required <code>tracks</code> <code>list[TrackData]</code> <p>List of track uuids to add to the playlist</p> required Source code in <code>chopin/managers/playlist.py</code> <pre><code>def fill(uri: str, tracks: list[TrackData]):\n    \"\"\"Fill a playlist with tracks.\n\n    !!! note\n        Duplicate tracks will be removed.\n\n    Args:\n        uri: uri of the playlist to fill\n        tracks: List of track uuids to add to the playlist\n    \"\"\"\n    track_ids = list(set([track.id for track in tracks]))\n    add_tracks_to_playlist(uri, track_ids)\n</code></pre>"},{"location":"reference/managers/#chopin.managers.playlist.shuffle_playlist","title":"<code>shuffle_playlist(name)</code>","text":"<p>Fetch a playlist from its name and shuffle_playlist it.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>playlist name.</p> required <p>Returns:</p> Type Description <code>PlaylistData</code> <p>Shuffled playlist data.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the playlist name was not found.</p> Source code in <code>chopin/managers/playlist.py</code> <pre><code>def shuffle_playlist(name: str) -&gt; PlaylistData:\n    \"\"\"Fetch a playlist from its name and shuffle_playlist it.\n\n    Args:\n        name: playlist name.\n\n    Returns:\n        Shuffled playlist data.\n\n    Raises:\n        ValueError: If the playlist name was not found.\n    \"\"\"\n    playlist = get_named_playlist(name)\n    if not playlist:\n        raise ValueError(f\"Playlist {name} not found.\")\n\n    tracks = get_playlist_tracks(playlist.id)\n    tracks = shuffle_tracks(tracks)\n    replace_tracks_in_playlist(playlist.id, track_ids=[track.id for track in tracks])\n    return playlist\n</code></pre>"},{"location":"reference/managers/#chopin.managers.playlist.summarize_playlist","title":"<code>summarize_playlist(playlist)</code>","text":"<p>From a given playlist, create its summary.</p> <p>Summaries are useful to describe and backup playlists. They contain extensive information about tracks, features, and can be serialized.</p> <p>Parameters:</p> Name Type Description Default <code>playlist</code> <code>PlaylistData</code> <p>The playlist to summarize.</p> required <p>Returns:</p> Type Description <code>PlaylistSummary</code> <p>A playlist summary, with extended informations about tracks and statistics.</p> Source code in <code>chopin/managers/playlist.py</code> <pre><code>def summarize_playlist(playlist: PlaylistData) -&gt; PlaylistSummary:\n    \"\"\"From a given playlist, create its summary.\n\n    Summaries are useful to describe and backup playlists. They contain extensive information about tracks,\n    features, and can be serialized.\n\n    Args:\n        playlist: The playlist to summarize.\n\n    Returns:\n        A playlist summary, with extended informations about tracks and statistics.\n    \"\"\"\n    tracks = get_playlist_tracks(playlist.id)\n    return PlaylistSummary(playlist=playlist, tracks=tracks)\n</code></pre>"},{"location":"reference/managers/#chopin.managers.playlist.tracks_from_playlist_name","title":"<code>tracks_from_playlist_name(playlist_name, nb_tracks, user_playlists, release_range=None, selection_method=None)</code>","text":"<p>Get a number of tracks from a playlist.</p> <p>Parameters:</p> Name Type Description Default <code>playlist_name</code> <code>str</code> <p>The name of your playlist</p> required <code>nb_tracks</code> <code>int</code> <p>Number of tracks to retrieve</p> required <code>user_playlists</code> <code>list[PlaylistData]</code> <p>List of existing user playlists. Used to map the name with the URI.</p> required <code>release_range</code> <code>ReleaseRange | None</code> <p>An optional datetime range for the release date of the tracks.</p> <code>None</code> <code>selection_method</code> <code>SelectionMethod | None</code> <p>How tracks are chosen from the retrieved tracks. See <code>SelectionMethod</code> for available methods. If no method is given, the choice will be random.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[TrackData]</code> <p>A list of track data from the playlists</p> Source code in <code>chopin/managers/playlist.py</code> <pre><code>def tracks_from_playlist_name(\n    playlist_name: str,\n    nb_tracks: int,\n    user_playlists: list[PlaylistData],\n    release_range: ReleaseRange | None = None,\n    selection_method: SelectionMethod | None = None,\n) -&gt; list[TrackData]:\n    \"\"\"Get a number of tracks from a playlist.\n\n    Args:\n        playlist_name: The name of your playlist\n        nb_tracks: Number of tracks to retrieve\n        user_playlists: List of existing user playlists. Used to map the name with the URI.\n        release_range: An optional datetime range for the release date of the tracks.\n        selection_method: How tracks are chosen from the retrieved tracks.\n            See `SelectionMethod` for available methods. If no method is given, the choice will be random.\n\n    Returns:\n        A list of track data from the playlists\n    \"\"\"\n    playlist = [\n        playlist for playlist in user_playlists if simplify_string(playlist_name) == simplify_string(playlist.name)\n    ]\n    if not playlist:\n        logger.warning(f\"Couldn't retrieve tracks for playlist {playlist_name}\")\n        return []\n    tracks = get_playlist_tracks(playlist_id=playlist[0].id, release_date_range=release_range)\n    return select_tracks(tracks, nb_tracks, selection_method)\n</code></pre>"},{"location":"reference/managers/#chopin.managers.playlist.tracks_from_playlist_uri","title":"<code>tracks_from_playlist_uri(playlist_uri, nb_tracks, release_range=None, selection_method=None)</code>","text":"<p>Get tracks from a playlist URI.</p> <p>Spotify API depreciation</p> <p>It must be a public playlist, and the playlist must not be owned by Spotify.</p> <p>Parameters:</p> Name Type Description Default <code>playlist_uri</code> <code>str</code> <p>Name of the artist or band to fetch related tracks from</p> required <code>nb_tracks</code> <code>int</code> <p>Number of tracks to retrieve.</p> required <code>release_range</code> <code>ReleaseRange | None</code> <p>An optional datetime range for the release date of the tracks.</p> <code>None</code> <code>selection_method</code> <code>SelectionMethod | None</code> <p>How tracks are chosen from the retrieved tracks. See <code>SelectionMethod</code> for available methods. If no method is given, the choice will be random.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[TrackData]</code> <p>A list of track data from the artist radio.</p> Source code in <code>chopin/managers/playlist.py</code> <pre><code>def tracks_from_playlist_uri(\n    playlist_uri: str,\n    nb_tracks: int,\n    release_range: ReleaseRange | None = None,\n    selection_method: SelectionMethod | None = None,\n) -&gt; list[TrackData]:\n    \"\"\"Get tracks from a playlist URI.\n\n    !!! warning \"Spotify API depreciation\"\n        It must be a _public_ playlist, and the playlist _must not be owned_ by Spotify.\n\n    Args:\n        playlist_uri: Name of the artist or band to fetch related tracks from\n        nb_tracks: Number of tracks to retrieve.\n        release_range: An optional datetime range for the release date of the tracks.\n        selection_method: How tracks are chosen from the retrieved tracks.\n            See `SelectionMethod` for available methods. If no method is given, the choice will be random.\n\n    Returns:\n        A list of track data from the artist radio.\n    \"\"\"\n    try:\n        tracks = get_playlist_tracks(playlist_id=playlist_uri, release_date_range=release_range)\n    except Exception:\n        logger.warning(f\"Couldn't retrieve playlist URI {playlist_uri}\")\n        return []\n    return select_tracks(tracks, nb_tracks, selection_method)\n</code></pre>"},{"location":"reference/managers/#chopin.managers.track.save_tracks","title":"<code>save_tracks(tracks)</code>","text":"<p>Add tracks to the current user liked songs.</p> <p>Parameters:</p> Name Type Description Default <code>tracks</code> <code>list[TrackData]</code> <p>Tracks to add</p> required Source code in <code>chopin/managers/track.py</code> <pre><code>def save_tracks(tracks: list[TrackData]):\n    \"\"\"Add tracks to the current user liked songs.\n\n    Args:\n        tracks: Tracks to add\n    \"\"\"\n    track_uris = [track.uri for track in tracks]\n    like_tracks(track_uris)\n</code></pre>"},{"location":"reference/managers/#chopin.managers.track.shuffle_tracks","title":"<code>shuffle_tracks(tracks)</code>","text":"<p>Shuffle a list of tracks.</p> <p>Parameters:</p> Name Type Description Default <code>tracks</code> <code>list[TrackData]</code> <p>Tracks to shuffle_playlist</p> required <p>Returns:</p> Type Description <code>list[TrackData]</code> <p>Updated list of tracks</p> Source code in <code>chopin/managers/track.py</code> <pre><code>def shuffle_tracks(tracks: list[TrackData]) -&gt; list[TrackData]:\n    \"\"\"Shuffle a list of tracks.\n\n    Args:\n        tracks: Tracks to shuffle_playlist\n\n    Returns:\n        Updated list of tracks\n    \"\"\"\n    return random.sample(tracks, len(tracks))\n</code></pre>"},{"location":"reference/schemas/","title":"Schemas","text":""},{"location":"reference/schemas/#base-schemas","title":"Base schemas","text":"<p>The base schemas are Pydantic models used to represent track, artist, album or playlist data.</p> <p>Pydantic schemas for albums.</p> <p>Pydantic schemas for artists.</p> <p>Pydantic schemas for playlists.</p> <p>Pydantic schemas for tracks.</p> <p>Pydantc schemas for users.</p>"},{"location":"reference/schemas/#chopin.schemas.album.AlbumData","title":"<code>AlbumData</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Album data representation.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Album name</p> <code>id</code> <code>str</code> <p>Album id</p> <code>uri</code> <code>str</code> <p>Spotify URI for the album</p> <code>release_date</code> <code>date | str</code> <p>The year the album was released.</p> Source code in <code>chopin/schemas/album.py</code> <pre><code>class AlbumData(BaseModel):\n    \"\"\"Album data representation.\n\n    Attributes:\n        name: Album name\n        id: Album id\n        uri: Spotify URI for the album\n        release_date: The year the album was released.\n    \"\"\"\n\n    model_config = ConfigDict(arbitrary_types_allowed=True)\n\n    name: str\n    id: str\n    uri: str\n    release_date: date | str\n\n    @field_validator(\"release_date\", mode=\"before\")\n    def release_date_validate(cls, v):\n        \"\"\"Format the release date based on the level of detail available.\"\"\"\n        if isinstance(v, str):\n            return parse_release_date(v)\n        return v\n</code></pre>"},{"location":"reference/schemas/#chopin.schemas.album.AlbumData.release_date_validate","title":"<code>release_date_validate(v)</code>","text":"<p>Format the release date based on the level of detail available.</p> Source code in <code>chopin/schemas/album.py</code> <pre><code>@field_validator(\"release_date\", mode=\"before\")\ndef release_date_validate(cls, v):\n    \"\"\"Format the release date based on the level of detail available.\"\"\"\n    if isinstance(v, str):\n        return parse_release_date(v)\n    return v\n</code></pre>"},{"location":"reference/schemas/#chopin.schemas.artist.ArtistData","title":"<code>ArtistData</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Artist data representation.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Name of the artist</p> <code>id</code> <code>str</code> <p>Id of the artist</p> <code>uri</code> <code>str</code> <p>Spotify URI for the artist</p> <code>genres</code> <code>list[str] | None</code> <p>A list of strings describing the artist genres</p> <p>Warning</p> <p>The 'genres' information is not always available. And it can be quite flaky</p> Source code in <code>chopin/schemas/artist.py</code> <pre><code>class ArtistData(BaseModel):\n    \"\"\"Artist data representation.\n\n    Attributes:\n        name: Name of the artist\n        id: Id of the artist\n        uri: Spotify URI for the artist\n        genres: A list of strings describing the artist genres\n\n    !!! warning\n        The 'genres' information is not always available. And it can be quite flaky\n    \"\"\"\n\n    name: str\n    id: str\n    uri: str\n    genres: list[str] | None = None\n\n    model_config = ConfigDict(extra=\"ignore\")\n</code></pre>"},{"location":"reference/schemas/#chopin.schemas.playlist.PlaylistData","title":"<code>PlaylistData</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Playlist representation.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Name of the playlist</p> <code>uri</code> <code>str</code> <p>Spotify URI for the playlist</p> Source code in <code>chopin/schemas/playlist.py</code> <pre><code>class PlaylistData(BaseModel):\n    \"\"\"Playlist representation.\n\n    Attributes:\n        name: Name of the playlist\n        uri: Spotify URI for the playlist\n    \"\"\"\n\n    name: str\n    uri: str\n    id: str\n    description: str = \"\"\n</code></pre>"},{"location":"reference/schemas/#chopin.schemas.playlist.PlaylistSummary","title":"<code>PlaylistSummary</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Representation of a full playlist. It is used to describe playlists and back them up.</p> <p>Attributes:</p> Name Type Description <code>playlist</code> <code>PlaylistData</code> <p>The playlist described</p> <code>tracks</code> <code>list[TrackData]</code> <p>A list of TrackData in the playlist</p> <code>_nb_tracks</code> <code>int | None</code> <p>Number of tracks in the playlist</p> <code>_total_duration</code> <code>float | None</code> <p>Length (in milliseconds) of the playlist</p> <code>_nb_artists</code> <code>int | None</code> <p>Number of artists in the playlist</p> <code>_avg_features</code> <code>int | None</code> <p>Average values across the track features</p> <code>_avg_popularity</code> <code>float | None</code> <p>Average popularity of the tracks in the playlist</p> <p>Note</p> <p>The private attributes are automatically computed in a validator.</p> Source code in <code>chopin/schemas/playlist.py</code> <pre><code>class PlaylistSummary(BaseModel):\n    \"\"\"Representation of a full playlist. It is used to describe playlists and back them up.\n\n    Attributes:\n        playlist: The playlist described\n        tracks: A list of TrackData in the playlist\n        _nb_tracks: Number of tracks in the playlist\n        _total_duration: Length (in milliseconds) of the playlist\n        _nb_artists: Number of artists in the playlist\n        _avg_features: Average values across the track features\n        _avg_popularity: Average popularity of the tracks in the playlist\n\n    !!! note\n        The private attributes are automatically computed in a validator.\n    \"\"\"\n\n    playlist: PlaylistData\n    tracks: list[TrackData]\n    _nb_tracks: int | None = None\n    _total_duration: float | None = None\n    _nb_artists: int | None = None\n    _avg_popularity: float | None = None\n\n    @model_validator(mode=\"after\")\n    def fill_fields(self):\n        \"\"\"Compute field values on initialzation.\"\"\"\n        tracks = self.tracks\n        popularities = [track.popularity for track in tracks]\n        self._nb_tracks = len(tracks)\n        self._nb_artists = len(set(track.artists[0].name for track in tracks))\n        self._total_duration = sum([track.duration_ms for track in tracks])\n        self._avg_popularity = sum(popularities) / len(popularities) if popularities else 0\n        return self\n\n    def __str__(self):\n        \"\"\"Represent a playlist summary.\"\"\"\n        return (\n            f\"------ Playlist {self.playlist.name} ------\\n\\t{self._nb_tracks} tracks\\n\\t{self._nb_artists} artists\\n\"\n        )\n\n    @model_serializer\n    def serialize_model(self):\n        \"\"\"Serialize plalist summaries and add version information.\"\"\"\n        return {\n            \"playlist\": self.playlist.model_dump(),\n            \"tracks\": [track.model_dump() for track in self.tracks],\n            \"version\": VERSION,\n        }\n</code></pre>"},{"location":"reference/schemas/#chopin.schemas.playlist.PlaylistSummary.__str__","title":"<code>__str__()</code>","text":"<p>Represent a playlist summary.</p> Source code in <code>chopin/schemas/playlist.py</code> <pre><code>def __str__(self):\n    \"\"\"Represent a playlist summary.\"\"\"\n    return (\n        f\"------ Playlist {self.playlist.name} ------\\n\\t{self._nb_tracks} tracks\\n\\t{self._nb_artists} artists\\n\"\n    )\n</code></pre>"},{"location":"reference/schemas/#chopin.schemas.playlist.PlaylistSummary.fill_fields","title":"<code>fill_fields()</code>","text":"<p>Compute field values on initialzation.</p> Source code in <code>chopin/schemas/playlist.py</code> <pre><code>@model_validator(mode=\"after\")\ndef fill_fields(self):\n    \"\"\"Compute field values on initialzation.\"\"\"\n    tracks = self.tracks\n    popularities = [track.popularity for track in tracks]\n    self._nb_tracks = len(tracks)\n    self._nb_artists = len(set(track.artists[0].name for track in tracks))\n    self._total_duration = sum([track.duration_ms for track in tracks])\n    self._avg_popularity = sum(popularities) / len(popularities) if popularities else 0\n    return self\n</code></pre>"},{"location":"reference/schemas/#chopin.schemas.playlist.PlaylistSummary.serialize_model","title":"<code>serialize_model()</code>","text":"<p>Serialize plalist summaries and add version information.</p> Source code in <code>chopin/schemas/playlist.py</code> <pre><code>@model_serializer\ndef serialize_model(self):\n    \"\"\"Serialize plalist summaries and add version information.\"\"\"\n    return {\n        \"playlist\": self.playlist.model_dump(),\n        \"tracks\": [track.model_dump() for track in self.tracks],\n        \"version\": VERSION,\n    }\n</code></pre>"},{"location":"reference/schemas/#chopin.schemas.track.TrackData","title":"<code>TrackData</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Representation of a track.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Track name</p> <code>id</code> <code>str</code> <p>Track id</p> <code>uri</code> <code>str</code> <p>Spotify URI for the track</p> <code>duration_ms</code> <code>int</code> <p>Duration of the track, in milliseconds</p> <code>popularity</code> <code>int | None</code> <p>A [0, 100] measure for the track popularity. 100 is most popular</p> <code>added_at</code> <code>FormattedDate | None</code> <p>A date, when available, for which the track was added in the playlist.</p> <code>album</code> <code>AlbumData | None</code> <p>The album data</p> <code>artists</code> <code>list[ArtistData] | None</code> <p>The artists on the track</p> <code>features</code> <code>list[ArtistData] | None</code> <p>Audio features of the track.</p> <p>Warning</p> <p>By default, tracks sent by the Spotify API do not contain audio feature information. A call to the dedicated endpoint is necessary to fill the attribute.</p> Source code in <code>chopin/schemas/track.py</code> <pre><code>class TrackData(BaseModel):\n    \"\"\"Representation of a track.\n\n    Attributes:\n        name: Track name\n        id: Track id\n        uri: Spotify URI for the track\n        duration_ms: Duration of the track, in milliseconds\n        popularity: A [0, 100] measure for the track popularity. 100 is most popular\n        added_at: A date, when available, for which the track was added in the playlist.\n        album: The album data\n        artists: The artists on the track\n        features: Audio features of the track.\n\n    !!! warning\n        By default, tracks sent by the Spotify API do not contain audio feature information.\n        A call to the dedicated endpoint is necessary to fill the attribute.\n    \"\"\"\n\n    name: str\n    id: str\n    uri: str\n    duration_ms: int\n    popularity: int\n    added_at: FormattedDate | None = None\n    album: AlbumData | None = None\n    artists: list[ArtistData] | None = None\n    popularity: int | None = 0\n\n    def to_flatten_dict(self, **kwargs):\n        \"\"\"Export the track data as a non-nested dictionary.\"\"\"\n        if isinstance(self.artists, list):\n            self.artists = self.artists[0]\n        return flatten_dict(self.model_dump(**kwargs))\n</code></pre>"},{"location":"reference/schemas/#chopin.schemas.track.TrackData.to_flatten_dict","title":"<code>to_flatten_dict(**kwargs)</code>","text":"<p>Export the track data as a non-nested dictionary.</p> Source code in <code>chopin/schemas/track.py</code> <pre><code>def to_flatten_dict(self, **kwargs):\n    \"\"\"Export the track data as a non-nested dictionary.\"\"\"\n    if isinstance(self.artists, list):\n        self.artists = self.artists[0]\n    return flatten_dict(self.model_dump(**kwargs))\n</code></pre>"},{"location":"reference/schemas/#chopin.schemas.track.datetime_to_date","title":"<code>datetime_to_date(dt)</code>","text":"<p>Truncate a datetime object into its date object.</p> Source code in <code>chopin/schemas/track.py</code> <pre><code>def datetime_to_date(dt: datetime | date | None) -&gt; date | None:\n    \"\"\"Truncate a datetime object into its date object.\"\"\"\n    if dt and isinstance(dt, datetime):\n        return dt.date()\n    return dt\n</code></pre>"},{"location":"reference/schemas/#chopin.schemas.user.UserData","title":"<code>UserData</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>User representation.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Name of the user</p> <code>id</code> <code>str</code> <p>The user id</p> <code>uri</code> <code>str</code> <p>Spotify URI for the user</p> Source code in <code>chopin/schemas/user.py</code> <pre><code>class UserData(BaseModel):\n    \"\"\"User representation.\n\n    Attributes:\n        name: Name of the user\n        id: The user id\n        uri: Spotify URI for the user\n    \"\"\"\n\n    name: str\n    id: str\n    uri: str\n</code></pre>"},{"location":"reference/schemas/#composer-schema","title":"Composer schema","text":"<p>The composer schema is used to configure your playlist composition. </p> <p>Schemas for playlist composition.</p>"},{"location":"reference/schemas/#chopin.schemas.composer.ComposerConfig","title":"<code>ComposerConfig</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Schema for a composer configuration.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Name of the playlist you wish to create</p> <code>description</code> <code>str</code> <p>Description for your playlist</p> <code>nb_songs</code> <code>Annotated[int, Field(gt=0)]</code> <p>Target number of songs for the playlist.</p> <code>playlists</code> <code>list[ComposerConfigItem] | None</code> <p>A list of playlist names and their weight.</p> <code>uris</code> <code>list[ComposerConfigItem] | None</code> <p>A list of spotify playlist URIs to pick from directly.</p> <code>history</code> <code>Annotated[list[ComposerConfigListeningHistory], Field(max_length=3)] | None</code> <p>Include past listening habits and most listened songs.</p> Source code in <code>chopin/schemas/composer.py</code> <pre><code>class ComposerConfig(BaseModel):\n    \"\"\"Schema for a composer configuration.\n\n    Attributes:\n        name: Name of the playlist you wish to create\n        description: Description for your playlist\n        nb_songs: Target number of songs for the playlist.\n        playlists: A list of playlist names and their weight.\n        uris: A list of spotify playlist URIs to pick from directly.\n        history: Include past listening habits and most listened songs.\n    \"\"\"\n\n    name: str = \"\ud83e\udd16 Robot Mix\"\n    description: str = \"Randomly generated mix\"\n    nb_songs: Annotated[int, Field(gt=0)]\n    release_range: Annotated[tuple[str | None, str | None] | None, AfterValidator(read_date)] | None = None\n    playlists: list[ComposerConfigItem] | None = []\n    history: Annotated[list[ComposerConfigListeningHistory], Field(max_length=3)] | None = []\n    uris: list[ComposerConfigItem] | None = []\n\n    @field_validator(\"history\")\n    def history_field_ranges_must_be_unique(cls, v):\n        \"\"\"Check the history items are distinct.\"\"\"\n        ranges = [item.time_range for item in v]\n        if len(set(ranges)) != len(ranges):\n            raise ValueError(\"time_range items for history must be unique\")\n        return v\n\n    @model_validator(mode=\"after\")\n    def fill_nb_songs(self) -&gt; \"ComposerConfig\":\n        \"\"\"From the nb_songs and item weights, compute the nb_songs of each item.\n\n        Args:\n            values: Attributes of the composer configuration model.\n        \"\"\"\n        item_weights: list[float] = [item.weight for category in SOURCES for item in getattr(self, category)]\n        sum_of_weights: float = sum(item_weights)\n        total_nb_songs: int = 0\n        for category in SOURCES:\n            for item in getattr(self, category):\n                item.nb_songs = math.ceil((item.weight / sum_of_weights) * self.nb_songs)\n                total_nb_songs += item.nb_songs\n        logger.info(f\"With the composer configuration parsed, {total_nb_songs} songs will be added.\")\n        return self\n\n    @computed_field\n    def items(self) -&gt; list[list[ComposerConfigItem]]:  # noqa: D102\n        return {source: getattr(self, source) for source in SOURCES}.items()\n\n    @classmethod\n    def parse_yaml(cls, file_path: Path) -&gt; Self:\n        \"\"\"Read a composer configuration from a YAML file.\n\n        Args:\n            file_path: The YAML file path.\n\n        Returns:\n            A valid composer configuration model.\n        \"\"\"\n        yaml = YAML(typ=\"safe\", pure=True)\n        with open(file_path) as f:\n            data = yaml.load(f)\n        return cls.model_validate(data)\n</code></pre>"},{"location":"reference/schemas/#chopin.schemas.composer.ComposerConfig.fill_nb_songs","title":"<code>fill_nb_songs()</code>","text":"<p>From the nb_songs and item weights, compute the nb_songs of each item.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <p>Attributes of the composer configuration model.</p> required Source code in <code>chopin/schemas/composer.py</code> <pre><code>@model_validator(mode=\"after\")\ndef fill_nb_songs(self) -&gt; \"ComposerConfig\":\n    \"\"\"From the nb_songs and item weights, compute the nb_songs of each item.\n\n    Args:\n        values: Attributes of the composer configuration model.\n    \"\"\"\n    item_weights: list[float] = [item.weight for category in SOURCES for item in getattr(self, category)]\n    sum_of_weights: float = sum(item_weights)\n    total_nb_songs: int = 0\n    for category in SOURCES:\n        for item in getattr(self, category):\n            item.nb_songs = math.ceil((item.weight / sum_of_weights) * self.nb_songs)\n            total_nb_songs += item.nb_songs\n    logger.info(f\"With the composer configuration parsed, {total_nb_songs} songs will be added.\")\n    return self\n</code></pre>"},{"location":"reference/schemas/#chopin.schemas.composer.ComposerConfig.history_field_ranges_must_be_unique","title":"<code>history_field_ranges_must_be_unique(v)</code>","text":"<p>Check the history items are distinct.</p> Source code in <code>chopin/schemas/composer.py</code> <pre><code>@field_validator(\"history\")\ndef history_field_ranges_must_be_unique(cls, v):\n    \"\"\"Check the history items are distinct.\"\"\"\n    ranges = [item.time_range for item in v]\n    if len(set(ranges)) != len(ranges):\n        raise ValueError(\"time_range items for history must be unique\")\n    return v\n</code></pre>"},{"location":"reference/schemas/#chopin.schemas.composer.ComposerConfig.parse_yaml","title":"<code>parse_yaml(file_path)</code>  <code>classmethod</code>","text":"<p>Read a composer configuration from a YAML file.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>Path</code> <p>The YAML file path.</p> required <p>Returns:</p> Type Description <code>Self</code> <p>A valid composer configuration model.</p> Source code in <code>chopin/schemas/composer.py</code> <pre><code>@classmethod\ndef parse_yaml(cls, file_path: Path) -&gt; Self:\n    \"\"\"Read a composer configuration from a YAML file.\n\n    Args:\n        file_path: The YAML file path.\n\n    Returns:\n        A valid composer configuration model.\n    \"\"\"\n    yaml = YAML(typ=\"safe\", pure=True)\n    with open(file_path) as f:\n        data = yaml.load(f)\n    return cls.model_validate(data)\n</code></pre>"},{"location":"reference/schemas/#chopin.schemas.composer.ComposerConfigItem","title":"<code>ComposerConfigItem</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Base schema for input in the composer configuration.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>Annotated[str, extract_uri_from_playlist_link]</code> <p>Name of the item. It should respect the simplify_string nomenclature</p> <code>weight</code> <code>Annotated[float, Field(ge=0)]</code> <p>Weight of the input in the final composition</p> Source code in <code>chopin/schemas/composer.py</code> <pre><code>class ComposerConfigItem(BaseModel):\n    \"\"\"Base schema for input in the composer configuration.\n\n    Attributes:\n        name: Name of the item. It should respect the simplify_string nomenclature\n        weight: Weight of the input in the final composition\n    \"\"\"\n\n    name: Annotated[str, extract_uri_from_playlist_link]\n    weight: Annotated[float, Field(ge=0)] = 1.0\n    nb_songs: int | None = 0\n    selection_method: SelectionMethod | None = SelectionMethod.RANDOM\n\n    @field_validator(\"name\", mode=\"before\")\n    def extract_uri_from_link(cls, v: str):\n        \"\"\"If the value is an https link to spotify, extract the URI data.\n\n        This allow users to share full links to their playlists.\n        \"\"\"\n        if v.startswith(\"https://open.spotify.com\"):\n            return extract_uri_from_playlist_link(v)\n        return v\n\n    @field_validator(\"selection_method\", mode=\"before\")\n    def lower_case_selection_method(cls, selection_method: str) -&gt; SelectionMethod:\n        \"\"\"Force the selection method to be lower case.\"\"\"  # TODO address this with proper enum handling\n        if selection_method:\n            return selection_method.lower()\n        return\n</code></pre>"},{"location":"reference/schemas/#chopin.schemas.composer.ComposerConfigItem.extract_uri_from_link","title":"<code>extract_uri_from_link(v)</code>","text":"<p>If the value is an https link to spotify, extract the URI data.</p> <p>This allow users to share full links to their playlists.</p> Source code in <code>chopin/schemas/composer.py</code> <pre><code>@field_validator(\"name\", mode=\"before\")\ndef extract_uri_from_link(cls, v: str):\n    \"\"\"If the value is an https link to spotify, extract the URI data.\n\n    This allow users to share full links to their playlists.\n    \"\"\"\n    if v.startswith(\"https://open.spotify.com\"):\n        return extract_uri_from_playlist_link(v)\n    return v\n</code></pre>"},{"location":"reference/schemas/#chopin.schemas.composer.ComposerConfigItem.lower_case_selection_method","title":"<code>lower_case_selection_method(selection_method)</code>","text":"<p>Force the selection method to be lower case.</p> Source code in <code>chopin/schemas/composer.py</code> <pre><code>@field_validator(\"selection_method\", mode=\"before\")\ndef lower_case_selection_method(cls, selection_method: str) -&gt; SelectionMethod:\n    \"\"\"Force the selection method to be lower case.\"\"\"  # TODO address this with proper enum handling\n    if selection_method:\n        return selection_method.lower()\n    return\n</code></pre>"},{"location":"reference/schemas/#chopin.schemas.composer.ComposerConfigListeningHistory","title":"<code>ComposerConfigListeningHistory</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Base schema for the configuration section which will add the current user's best songs.</p> <p>Attributes:</p> Name Type Description <code>time_range</code> <code>Literal['short_term', 'medium_term', 'long_term']</code> <p>Time criteria for the best tracks. One of short_term (~ last 4 weeks), medium_term (~ last 6 months) or long_term (~ all time).</p> <code>weight</code> <code>Annotated[float, Field(ge=0)]</code> <p>Weight of the input in the final composition</p> Source code in <code>chopin/schemas/composer.py</code> <pre><code>class ComposerConfigListeningHistory(BaseModel):\n    \"\"\"Base schema for the configuration section which will add the current user's best songs.\n\n    Attributes:\n        time_range: Time criteria for the best tracks. One of short_term (~ last 4 weeks), medium_term (~ last 6 months)\n            or long_term (~ all time).\n        weight: Weight of the input in the final composition\n    \"\"\"\n\n    time_range: Literal[\"short_term\", \"medium_term\", \"long_term\"] = \"short_term\"\n    weight: Annotated[float, Field(ge=0)] = 1\n    nb_songs: int | None = 0\n</code></pre>"},{"location":"reference/tools/","title":"Tools","text":"<p>Helper modules for Chopin</p>"},{"location":"reference/tools/#dates","title":"Dates","text":"<p>Date range utilitaries.</p>"},{"location":"reference/tools/#chopin.tools.dates.parse_release_date","title":"<code>parse_release_date(date)</code>","text":"<p>Parse the release date depending on the level of detail available.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>str</code> <p>An input date, as a string</p> required <p>Returns:</p> Type Description <code>date</code> <p>A formatted date, with the datetime library.</p> Source code in <code>chopin/tools/dates.py</code> <pre><code>def parse_release_date(date: str) -&gt; date:\n    \"\"\"Parse the release date depending on the level of detail available.\n\n    Args:\n        date: An input date, as a string\n\n    Returns:\n        A formatted date, with the datetime library.\n    \"\"\"\n    if not date:\n        return datetime(1970, 1, 1, 0, 0).date()\n    match len(date):\n        case 4:\n            _format = \"%Y\"\n        case 7:\n            _format = \"%Y-%m\"\n        case 10:\n            _format = \"%Y-%m-%d\"\n        case 19:\n            _format = \"%Y-%m-%dT%M:%S:%f\"\n        case _:\n            raise ValueError(f\"Bad release date format: {date}\")\n    return datetime.strptime(date, _format).date()\n</code></pre>"},{"location":"reference/tools/#chopin.tools.dates.read_date","title":"<code>read_date(date)</code>","text":"<p>Read a date from  a string tuple.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>tuple[str | None, str | None] | None</code> <p>The date to parse</p> required <p>Returns:</p> Type Description <code>ReleaseRange | None</code> <p>A parsed date (if it exists), e.g. a range of two datetime objects.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; read_date('10/01/2023', '10/02/2023')\n(datetime.datetime(2023, 1, 10, 0, 0), datetime.datetime(2023, 2, 10, 0, 0))\n&gt;&gt;&gt; read_date('10/01/2023', )\n(datetime.datetime(2023, 1, 10, 0, 0), datetime.datetime.now()\n</code></pre> Source code in <code>chopin/tools/dates.py</code> <pre><code>def read_date(date: tuple[str | None, str | None] | None) -&gt; ReleaseRange | None:\n    \"\"\"Read a date from  a string tuple.\n\n    Args:\n        date: The date to parse\n\n    Returns:\n        A parsed date (if it exists), e.g. a range of two datetime objects.\n\n    Examples:\n        &gt;&gt;&gt; read_date('10/01/2023', '10/02/2023')\n        (datetime.datetime(2023, 1, 10, 0, 0), datetime.datetime(2023, 2, 10, 0, 0))\n        &gt;&gt;&gt; read_date('10/01/2023', )\n        (datetime.datetime(2023, 1, 10, 0, 0), datetime.datetime.now()\n    \"\"\"\n    _format = \"%d/%m/%Y\"\n    match date:\n        case None:\n            return date\n        case (str(), str()):\n            return datetime.strptime(date[0], _format), datetime.strptime(date[1], _format)\n        case (str(), None):\n            return datetime.strptime(date[0], _format), datetime.now()\n        case (None, str()):\n            return datetime.strptime(\"01/01/1900\", _format), datetime.strptime(date[1], _format)\n</code></pre>"},{"location":"reference/tools/#dictionaries","title":"Dictionaries","text":"<p>Utilities to help with dictionaries.</p>"},{"location":"reference/tools/#chopin.tools.dictionaries.flatten_dict","title":"<code>flatten_dict(dictionary)</code>","text":"<p>Flatten a dictionary with potential nested dictionaries, into a single dictionary.</p> <p>Example</p> <p><pre><code>{'my_key': 'my_value',\n 'a_nested_dict':\n    {'my_key': 'my_value',\n     'version': '1'\n     }\n}\n</code></pre> will become:</p> <pre><code>{'my_key': 'my_value',\n 'a_nested_dict.my_key' : 'my_value',\n 'a_nested_dict.version': '1'\n}\n</code></pre> Source code in <code>chopin/tools/dictionaries.py</code> <pre><code>def flatten_dict(dictionary: dict) -&gt; dict:\n    \"\"\"Flatten a dictionary with potential nested dictionaries, into a single dictionary.\n\n    !!! example\n        ```\n        {'my_key': 'my_value',\n         'a_nested_dict':\n            {'my_key': 'my_value',\n             'version': '1'\n             }\n        }\n        ```\n        will become:\n\n        ```\n        {'my_key': 'my_value',\n         'a_nested_dict.my_key' : 'my_value',\n         'a_nested_dict.version': '1'\n        }\n        ```\n    \"\"\"\n    final_dict = {}\n    for key, value in dictionary.items():\n        if isinstance(value, dict):\n            for sub_key, sub_value in value.items():\n                final_dict[f\"{key}.{sub_key}\"] = sub_value\n        else:\n            final_dict[key] = value\n    return final_dict\n</code></pre>"},{"location":"reference/tools/#strings","title":"Strings","text":"<p>Utilites to help deal with strings.</p>"},{"location":"reference/tools/#chopin.tools.strings.decode","title":"<code>decode(encoded_string, alphabet=BASE62)</code>","text":"<p>Decode a Base X encoded string into the number.</p> <p>Parameters:</p> Name Type Description Default <code>encoded_string</code> <p>The encoded string</p> required <code>alphabet</code> <p>Alphabet to use for decoding</p> <code>BASE62</code> <p>Returns:</p> Type Description <code>str</code> <p>The decoded string</p> Source code in <code>chopin/tools/strings.py</code> <pre><code>def decode(encoded_string, alphabet=BASE62) -&gt; str:\n    \"\"\"Decode a Base X encoded string into the number.\n\n    Args:\n        encoded_string: The encoded string\n        alphabet: Alphabet to use for decoding\n\n    Returns:\n        The decoded string\n    \"\"\"\n    base = len(alphabet)\n    strlen = len(encoded_string)\n    num = 0\n\n    idx = 0\n    for char in encoded_string:\n        power = strlen - (idx + 1)\n        num += alphabet.index(char) * (base**power)\n        idx += 1\n\n    decoded = \"\".join(chr((num &gt;&gt; 8 * (len(BASE62) - byte - 1)) &amp; 0xFF) for byte in range(len(BASE62)))\n    return decoded\n</code></pre>"},{"location":"reference/tools/#chopin.tools.strings.extract_uri_from_playlist_link","title":"<code>extract_uri_from_playlist_link(playlist_link)</code>","text":"<p>Parse a playlist link and returns the playlist URI. The playlist URI is later used to query the Spotify API.</p> Example <p><code>https://open.spotify.com/playlist/37i9dQZF1DWWv8B5EWK7bn?si=8d52c3fef8d74064</code> becomes <code>37i9dQZF1DWWv8B5EWK7bn</code></p> <p>Parameters:</p> Name Type Description Default <code>playlist_link</code> <code>str</code> <p>https link to a Spotify playlist.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The playlist URI</p> Source code in <code>chopin/tools/strings.py</code> <pre><code>def extract_uri_from_playlist_link(playlist_link: str) -&gt; str:\n    \"\"\"Parse a playlist link and returns the playlist URI. The playlist URI is later used to query the Spotify API.\n\n    ??? example\n        `https://open.spotify.com/playlist/37i9dQZF1DWWv8B5EWK7bn?si=8d52c3fef8d74064` becomes `37i9dQZF1DWWv8B5EWK7bn`\n\n    Args:\n        playlist_link: https link to a Spotify playlist.\n\n    Returns:\n        The playlist URI\n    \"\"\"\n    pattern = r\"playlist/([a-zA-Z0-9]+)\\?\"\n    match = re.search(pattern, playlist_link)\n    if match:\n        return match.group(1)\n    return \"\"\n</code></pre>"},{"location":"reference/tools/#chopin.tools.strings.match_strings","title":"<code>match_strings(strings)</code>","text":"<p>Check if all strings match.</p> <p>They match if their lowercase, unicode stripped-off characters versions are similar.</p> <p>Parameters:</p> Name Type Description Default <code>strings</code> <code>list[str]</code> <p>A list of strings to match</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if all strings are the same (minus lowercase and unicode special character differences)</p> Source code in <code>chopin/tools/strings.py</code> <pre><code>def match_strings(strings: list[str]) -&gt; bool:\n    \"\"\"Check if all strings match.\n\n    They match if their lowercase, unicode stripped-off characters versions are similar.\n\n    Args:\n        strings: A list of strings to match\n\n    Returns:\n        True if all strings are the same (minus lowercase and unicode special character differences)\n    \"\"\"\n\n    def _normalize_string(_string: str) -&gt; str:\n        return \"\".join(c for c in unicodedata.normalize(\"NFD\", _string.lower()) if unicodedata.category(c) != \"Mn\")\n\n    if len(strings) &lt; 2:\n        return True\n    target = _normalize_string(strings[0])\n    return all([_normalize_string(s) == target for s in strings[1:]])\n</code></pre>"},{"location":"reference/tools/#chopin.tools.strings.owner_is_spotify","title":"<code>owner_is_spotify(uri)</code>","text":"<p>Test if the given URI is owned by spotify.</p> <p>Parameters:</p> Name Type Description Default <code>uri</code> <code>str</code> <p>URI to test</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if 'spotify' is the owner of the URI item.</p> Source code in <code>chopin/tools/strings.py</code> <pre><code>def owner_is_spotify(uri: str) -&gt; bool:\n    \"\"\"Test if the given URI is owned by spotify.\n\n    Args:\n        uri: URI to test\n\n    Returns:\n        True if 'spotify' is the owner of the URI item.\n    \"\"\"\n    decoded = \"\".join([char for char in decode(uri) if char.isalnum()])\n    return decoded.startswith(\"format\")\n</code></pre>"},{"location":"reference/tools/#chopin.tools.strings.simplify_string","title":"<code>simplify_string(text)</code>","text":"<p>Simplify a string: lowercase, and no emojis.</p> Source code in <code>chopin/tools/strings.py</code> <pre><code>def simplify_string(text: str) -&gt; str:\n    \"\"\"Simplify a string: lowercase, and no emojis.\"\"\"\n    text = emoji.replace_emoji(text)\n    text = text.lower()\n    text = text.rstrip(\" \")\n    text = text.lstrip(\" \")\n    text = text.replace(\"'\", \"\")\n    text = text.replace(\" \", \"\")\n    text = text.replace(\"&amp;\", \"_\")\n    return text\n</code></pre>"}]}